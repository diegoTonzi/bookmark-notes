plugins {
  id 'net.researchgate.release' version '2.4.0'
}


defaultTasks 'info'


ext {
	BOOKMARKS_TAG = project.version
	CONTAINER_NAME = "bookmarks-node"
	IMAGE_NAME = "reg.mageddo.com:5000/mageddo/${CONTAINER_NAME}:$BOOKMARKS_TAG"
	BOOKMARKS_BASE = "/var/lib/mageddo/bookmarks-node"
	BOOKMARKS_INTERNAL_BASE = "/opt/bookmarks"
}
def lastVersion = project.version
beforeReleaseBuild << {
	println "> upgrading docker-compose version from: ${lastVersion} to ${project.version}"
	def f = new File("${project.projectDir}/docker-compose.yml")
	if(!f.exists()){
		println "docker-compose file not found"
		System.exit(-1)
	}
	f.write(f.text.replaceAll("(image:.*:)(.*)", "\$1${project.version}"))
}
release {
	project.ext.set("release.useAutomaticVersion", true)
	failOnCommitNeeded = false
	failOnPublishNeeded = false
	failOnUnversionedFiles = false
	buildTasks = []
}


task 'info' << {
	println """
	tag      : ${project.BOOKMARKS_TAG}
	container: ${project.CONTAINER_NAME}
	image    : ${project.IMAGE_NAME}
	"""
}

/**
 * roda o sistema em modo dev
 * este método já chama o build e up necessário
 */
task 'build' (dependsOn: [
		'docker-build', 'docker-up'
]) << {

}

/**
 * roda o sistema em modo dev
 * este método já chama o build e up necessário
 */
task 'build-prod' (dependsOn: [
		'docker-build', 'docker-up-prod'
]) << {

}

/**
 * roda o php em modo dev
 * este método já chama o build e up necessário
 */
task 'docker-build' (type:Exec) {
	commandLine = ['docker', 'build', '--rm', '--tag',
								 "${IMAGE_NAME}", '.'
	]
}

/**
 * roda o sistema para dev
 */
task 'docker-up' (type:Exec) {
	def pwd = new File(".").absolutePath
	removeContainer(CONTAINER_NAME)
	commandLine = [
			'docker', 'run', '-d', '--hostname', 'bookmarks.mageddo',
			'--publish', '3000:3000',
			'--expose', '3000',
			'--env', 'MG_MODE=debug',
			'--volume', "${pwd}:${BOOKMARKS_INTERNAL_BASE}",
			'--volume', "${BOOKMARKS_BASE}/db:${BOOKMARKS_INTERNAL_BASE}/db",
			'--name', CONTAINER_NAME, IMAGE_NAME
	]
}

/**
 * roda o sistema para prod
 */
task 'docker-up-prod' (type:Exec) {
	removeContainer(CONTAINER_NAME)
	commandLine = getProdParams()
}

/**
 * apaga todas as imagens e containers
 * gerados por este projeto
 */
task 'docker-clear' << {
	removeImage(IMAGE_NAME)
}

/**
 * Pega a última imagem builda (rode gradle build para isso) e
 * sobe para produção, obs: o seu ssh precisa estar configurado para logar automaticamente no
 * usuário elvis e a pasta ~/Downloads/scripts precisa estar em produção
 */
task deployProd(type: Exec) {
	def PROD_PARAMS = toProdParams();
	commandLine = [
			'sh', '-c', "./deployProd ${IMAGE_NAME} '${PROD_PARAMS}' ${CONTAINER_NAME}"
	]
}

def toProdParams(){
	def params = getProdParams();
	def str = "";
	for(String param: params){
		str += param;
		str += " ";
	}
	return str;
}
def getProdParams(){
	return [
			'docker', 'run', '-d', '--hostname', 'bookmarks.mageddo',
			'--publish', '3000:3000',
			'--expose', '3000',
			'--env', 'MG_MODE=production',
			'--volume', "${BOOKMARKS_BASE}/db:${BOOKMARKS_INTERNAL_BASE}/db",
			'--volume', "${BOOKMARKS_BASE}/logs:${BOOKMARKS_INTERNAL_BASE}/logs",
			'--name', CONTAINER_NAME, IMAGE_NAME
	]
}

def removeLast(String str) {
	str.substring(0, str.indexOf("\n"));
}
def getTheTag(){
	def tag = ['git', 'tag', '-l', '--sort=-taggerdate'].execute().text;
	logger.info("M=getTheTag, length={}", tag.length())
	if(tag.length() != 1)
		return removeLast(tag)
	return '1.0.0'
}
def removeContainer(String image){
	def buff = new StringBuffer();
	def proc = ['docker', 'rm', '-f', image].execute();
	proc.consumeProcessOutput(buff, buff)
	proc.waitForOrKill(10000);
	//println buff
}
def removeImage(String image){
	def buff = new StringBuffer();
	def proc = ['docker', 'rmi', '-f', image].execute();
	proc.consumeProcessOutput(buff, buff)
	proc.waitForOrKill(10000);
	//println buff
}